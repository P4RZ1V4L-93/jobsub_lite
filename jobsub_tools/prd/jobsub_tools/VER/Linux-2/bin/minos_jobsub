#!/bin/sh
#
# This script handles all the messy business with job submission
# to the local MINOS nodes and the FNAL Grid nodes.
# 

VERSION=20140415

# who are we?
thisscript=`basename $0`
fullargs="$@"

# utils
RP=${MINOS_CONDOR}/scripts/realpath/realpath_mod.pl

# groups file
GROUPFILE=${MINOS_CONDOR}/etc/minos_groups.cfg

# Usage info
function print_advice {
  echo "Type '"${thisscript}" -h' for help."
}
function print_usage {
  echo "Usage: "${thisscript}" [args] executable [exec_args]"
  echo "Possible [args]:"
  echo
  echo " Generic stuff:"
  echo "    -h             Print this help."
  echo
  echo "    -n             Create the .cmd file and output its name, but"
  echo "                   do not submit the job(s).  You can later submit"
  echo "                   the job with:"
  echo "                       condor_submit <cmd_file>"
  echo
  echo "    -N <num>       Submit <num> copies of the job.  Each job will"
  echo "                   have access to the environment variable"
  echo "                   \$PROCESS that provides the job number (0 to"
  echo "                   <num>-1), equivalent to the decimal point in"
  echo "                   the job ID (the '2' in 134567.2)."
  echo
  echo "    -q             Only send email notification if the job ends"
  echo "                   with an error.  (Default is always to email.)"
  echo
  echo "    -Q             No email notification ever."
  echo
  echo "    -T             Submit as a test job.  Job will run with highest"
  echo "                   possible priority, but you can only have one such"
  echo "                   job in the queue at a time."
  echo
  echo " Minossoft and enstore:"
  echo "    -O             Set up optimized minossoft (requires -r or -t)."
  echo
  echo "    -r <rel>       Set up minossoft release <rel> at the beginning"
  echo "                   of the job."
  echo
  echo "    -t <dir>       Set up the test release in <dir> at the"
  echo "                   beginning of the job.  -r is not needed."
  echo
  echo "    -y <file>      Get <file> (usually of the form /pnfs/...) from"
  echo "                   Enstore, point \$FROM_ENSTORE to it, and clean up"
  echo "                   when finished.  You can use multiple -y options"
  echo "                   if you want \$FROM_ENSTORE to point to multiple"
  echo "                   files.  You can also specify non-Enstore files if"
  echo "                   you want.  (Perhaps you have a mixture of input.)"
  echo "                   Requires either -r or -t to get access to dccp."
  echo
  echo " Environment:"
  echo "    -c <ClassAd>   Add condition <ClassAd> to the job.  (See"
  echo "                   documentation on Condor ClassAds for more.)"
  echo 
#  echo "    -C             Start job in current directory.  (Directory"
#  echo "                   must be visible on the execution node.)  Now"
#  echo "                   default, so specifying this does nothing."
#  echo
  echo "    -e <var>       Pass the existing environment variable <var>"
  echo "                   into the job.  (No \"\$\", e.g.: \"-e MYVAR\".)"
  echo
  echo "    -l <line>      [Expert option]  Add the line <line> to the"
  echo "                   Condor submission (.cmd) file.  See Condor"
  echo "                   help for more."
  echo
  echo " Grid running:"
  echo "    -g             Run the job on the FNAL Grid."
  echo
  echo "    -d<tag> <dir>  Writable directory \$CONDOR_DIR_<tag> will exist"
  echo "                   on the execution node.  After job completion,"
  echo "                   its contents can be moved to <dir> automatically"
  echo "                   by running the script minos_harvestfiles on a"
  echo "                   MINOS machine.  This allows you to specify at"
  echo "                   submission time where your job's output should"
  echo "                   eventually end up, and minos_harvestfiles does"
  echo "                   the necessary moving for you.  Specify as many"
  echo "                   <tag>/<dir> pairs as you need."
  echo
  echo " Miscellaneous:"
  echo "    -G <group>     Submit job under group <group>.  This is to allow"
  echo "                   high priority submission for batch production and"
  echo "                   critical analysis tasks.  (Use of groups requires"
  echo "                   express permission.)"
  echo
  echo " AFS flags.  You should never need any of these:"
  echo "    -a             [ DEPRECATED ] Does nothing now."
  echo
  echo "    -p             Run job under Parrot.  Automatically selected"
  echo "                   when running on Grid (-g), so you should never"
  echo "                   need to set this option explicitly."
  echo
  echo "    -pOFF          Do NOT use Parrot when running on the Grid.  Your"
  echo "                   job will not have AFS access in general.  This"
  echo "                   setting is available mostly for testing.  You"
  echo "                   shouldn't need to use -pOFF."
  echo
  echo
  echo " NOTES:"
  echo "   You can have as many instances of -c, -d, -e, -l and -y as you need."
  echo
  echo "   The -d directory mapping works on non-Grid nodes, too."
  echo
}


# Got $CONDOR_TMP?
if [ -z "${CONDOR_TMP}" ]
then
  echo "WARNING: \$CONDOR_TMP is undefined.  This shouldn't be the case."
  CONDOR_TMP=/minos/data/condor-tmp/${LOGNAME}
  echo "  Assuming CONDOR_TMP="${CONDOR_TMP}
fi

# Got $CONDOR_EXEC?
if [ -z "${CONDOR_EXEC}" ]
then
  echo "WARNING: \$CONDOR_EXEC is undefined.  This shouldn't be the case."
  CONDOR_EXEC=/minos/app/condor-exec/${LOGNAME}
  echo "  Assuming CONDOR_EXEC="${CONDOR_EXEC}
fi

# at the moment, no override!
# # Where files will go.  May be overridden with -d <dir>, expect
# # the wrapper and any mapped output dirs
# OUTDIR=${CONDOR_TMP}

#defaults
ISTESTJOB=0
NEEDAFS=0
NOTIFY=2
SUBMIT=1
GRID=0
USEPWD=1
FORCEPARROT=0
FORCENOPARROT=0
NEEDMINOSSOFT=0
REQUIREMENTS="((Arch==\"X86_64\") || (Arch==\"INTEL\"))"
ENVIRONMENT="PROCESS=\$(Process);CONDOR_TMP=${CONDOR_TMP};CONDOR_EXEC=${CONDOR_EXEC}"
LINES=""
GROUP=""
TAG_COUNTER=0
ENSTOREFILES=""
QUEUECOUNT=""
REL=""
TESTRELDIR=""
MSOPT=""

# Peel off args
while [ $# -gt 0 ] && [ "${1/-}" = "${1:1}" ]
do
  argshift=0
  if [ "${1/-d}" = "${1:2}" ]
  then
    # handle output dir mapping
    TAG=${1:2}
    if [ -n "$TAG" ]
    then
      TAG_ARRAY[${TAG_COUNTER}]=${TAG}
      DIR_ARRAY[${TAG_COUNTER}]=${2}
      TAG_COUNTER=$(( TAG_COUNTER + 1 ))
      argshift=2
    else
      echo "minos_jobsub: -dTAG option is missing TAG"
      print_advice
      exit 1
    fi
  else
    case $1 in
      -h)
  	print_usage
  	exit
  	;;
      -a)
        # disabled now
  	#NEEDAFS=1
  	argshift=1
  	;;
      -p)
  	FORCEPARROT=1
  	argshift=1
  	;;
      -pOFF)
  	FORCENOPARROT=1
  	argshift=1
  	;;
      -r)
  	REL=$2
  	argshift=2
  	;;
      -n)
  	SUBMIT=0
  	argshift=1
  	;;
      -N)
  	QUEUECOUNT=$2
  	argshift=2
  	;;
      -t)
  	TESTRELDIR=$2
  	argshift=2
  	;;
      -G)
  	GROUP=$2
  	argshift=2
  	;;
      -O)
  	MSOPT="-O"
  	argshift=1
  	;;
      -q)
  	NOTIFY=1
  	argshift=1
  	;;
      -Q)
  	NOTIFY=0
  	argshift=1
  	;;
      -T)
  	ISTESTJOB=1
  	argshift=1
  	;;
      -g)
  	GRID=1
  	argshift=1
  	;;
      -c)
        REQUIREMENTS=${REQUIREMENTS}" && ("$2")"
  	argshift=2
  	;;
      -C)
        USEPWD=1
  	argshift=1
  	;;
      -e)
  	ENVIRONMENT=${ENVIRONMENT}";"$2"=\$ENV("$2")"
  	argshift=2
  	;;
      -y)
        ENSTOREFILES="${ENSTOREFILES} $2"
        argshift=2
  	;;
      -l)
  	LINES=${LINES}$2"\n"
  	argshift=2
  	;;
      *)
  	echo ${thisscript}": invalid option -- "$1
        print_advice
  	exit 1
  	;;
    esac
  fi

  # make sure we got what we needed
  if [ ${argshift} -gt $# ]
  then
    echo ${thisscript}": missing argument for "$1
    print_advice
    exit 1
  else
    shift ${argshift}
  fi
done

# now the user exec
if [ $# -gt 0 ]
then
  USEREXEC=$1
  shift 1
else
  echo ${thisscript}": no executable specified"
  print_advice
  exit 1
fi

# user args
# quotes in args need to be protected from the shell; need improvement...
USERARGS=$*

# the proxy file, if needed (can't verify on non-minos25 nodes)
X509USERPROXY=/local/scratch25/${LOGNAME}/grid/${LOGNAME}.proxy


##########
# sanity #
##########

if [ -n "$TESTRELDIR" ] && [ ! -d "$TESTRELDIR" ]
then
  echo "minos_jobsub: $TESTRELDIR is not a directory."
  print_advice
  exit 1
fi

if [ -n "$TESTRELDIR" ] && [ ! -e "$TESTRELDIR/.base_release" ]
then
  echo "minos_jobsub: $TESTRELDIR does not seem to hold a test release."
  print_advice
  exit 1
elif [ -n "$TESTRELDIR" ]
then
  TESTREL="`cat $TESTRELDIR/.base_release`"
fi

if [ -n "$TESTRELDIR" ] && [ -n "$REL" ] && [ "$REL" != "$TESTREL" ]
then
  echo "minos_jobsub: Test release at $TESTRELDIR does not appear"
  echo "to use minossoft release ${REL}.  Omit the -r <rel> option to use the test"
  echo "release's native verion (${TESTREL})."
  print_advice
  exit 1
fi

if [ -z "$REL" ] && [ -z "$TESTREL" ] && [ -n "$MSOPT" ]
then
  echo "minos_jobsub: Using -O without specifying a release makes no sense."
  print_advice
  exit 1
fi

if [ "$GRID" -eq 0 ] && [ "$NEEDAFS" -eq 1 ]
then
  echo "minos_jobsub: -a without -g makes no sense"
  print_advice
  exit 1
fi

if [ "$FORCENOPARROT" -eq 1 ] && [ "$FORCEPARROT" -eq 1 ]
then
  echo "minos_jobsub: -p and -pOFF together makes no sense"
  print_advice
  exit 1
fi

if [ "$NEEDAFS" -eq 1 ] && [ "$FORCEPARROT" -eq 1 ]
then
  echo "WARNING: Using -a and -p together is weird.  Are you sure you meant that?"
fi

#if [ -n "$REL" ] && [ "$GRID" -eq 1 ] && [ "$NEEDAFS" -eq 0 ] && [ "$FORCENOPARROT" -eq 1 ]
#then
#  echo "minos_jobsub: You have turned off Parrot (-pOFF) but you are requesting"
#  echo "minossoft for a Grid job.  This doesn't work.  Did you mean to use -a ?"
#  print_advice
#  exit 1
#fi

if [ -z "$REL" ] && [ -z "$TESTREL" ] && [ -n "$ENSTOREFILES" ]
then
  echo "minos_jobsub: You must set up a minossoft release (-r or -t) if you want to use the dCache utilities (-y)."
  print_advice
  exit 1
fi


##############################
# filenames, variables, etc. #
##############################

# AFS manipulation
USEPARROT=0
if ( [ "$GRID" -eq 1 ] && [ "$FORCEPARROT" -eq 1 ] && [ "$NEEDAFS" -eq 0 ] ) || [ "$FORCEPARROT" -eq 1 ]
then
  USEPARROT=1
fi

# release manipulation
if [ -n "$TESTREL" ]
then
  REL=$TESTREL
fi

# test job?  if so, verify...
if [ "$ISTESTJOB" -eq 1 ]
then
  NUMTESTJOBS=`condor_q ${LOGNAME} -const \'\(AccountingGroup=?=\"group_testjobs\"\)\' | grep -c ${LOGNAME}`
  if [ "$NUMTESTJOBS" -gt 0 ]
  then
    echo
    echo "minos_jobsub: Sorry, you're only allowed one test job at a time."
    echo
    echo "The following are the test jobs you already have in the queue:"
    condor_q ${LOGNAME} -const \'\(AccountingGroup=?=\"group_testjobs\"\)\'
    exit 1
  fi
  if [ "$QUEUECOUNT" != "" ]
  then
    if [ "$QUEUECOUNT" -gt 1 ]
    then
      echo "WARNING: Multiple jobs requested (-N) but test job priority requested (-T).  Only submitting one test job."
      QUEUECOUNT=""
    fi
  fi
fi

# group requested?  if so, verify
if [ -n "$GROUP" ]
then
  export EXPGROUP=$GROUP
  GROUPOKAY=`cat $GROUPFILE | grep -v "#" | awk '{if (NF==1&&$1==ENVIRON["EXPGROUP"]) print $0}' | wc -l`
  if [ "$GROUPOKAY" -eq 0 ]
  then
    echo "minos_jobsub: Requested group ($GROUP) not recognized.  Contact admin for a new group if you need one."
    exit 1
  fi
fi

uniquer=1
FILEBASE=`basename ${USEREXEC}`_`date +%Y%m%d_%H%M%S`
while [ -e `echo ${CONDOR_TMP}/${FILEBASE}_${uniquer}* | cut -d " " -f 1` ]
do
  uniquer=$(( uniquer + 1))  
done
WRAPFILE=${CONDOR_EXEC}/${FILEBASE}_${uniquer}_wrap.sh
PARROTFILE=${CONDOR_EXEC}/${FILEBASE}_${uniquer}_parrot.sh
FILEBASE=${CONDOR_TMP}/${FILEBASE}_${uniquer}
CMDFILE=${FILEBASE}.cmd

# these get a $(Process) tag if -N is used
if [ -n "$QUEUECOUNT" ]
then
  PROCESSTAG="_\$(Process)"
else
  PROCESSTAG=""
fi
LOGFILE=${FILEBASE}${PROCESSTAG}.log
ERRFILE=${FILEBASE}${PROCESSTAG}.err
OUTFILE=${FILEBASE}${PROCESSTAG}.out

# any directory mapping?
i=0
while [ $i -lt $TAG_COUNTER ]
do
  ENVIRONMENT=${ENVIRONMENT}";CONDOR_DIR_"${TAG_ARRAY[$i]}"="${FILEBASE}${PROCESSTAG}"_dir_"${TAG_ARRAY[$i]}
  i=$(( i + 1 ))
done


#######################
# build the .cmd file #
#######################

# first, the basics
echo "universe      = vanilla" >> $CMDFILE
if [ "$USEPARROT" -eq 1 ]
then
  echo "executable    = "$PARROTFILE >> $CMDFILE
else
  echo "executable    = "$WRAPFILE >> $CMDFILE
fi
echo "arguments     = "$USERARGS >> $CMDFILE
echo "output        = "${OUTFILE} >> $CMDFILE
echo "error         = "${ERRFILE} >> $CMDFILE
echo "log           = "${LOGFILE} >> $CMDFILE
echo "environment   = "$ENVIRONMENT >> $CMDFILE
echo "rank          = Mips / 2 + Memory" >> $CMDFILE

# notification options
if [ "$NOTIFY" -eq 0 ]
then
  echo "notification  = Never" >> $CMDFILE
elif [ "$NOTIFY" -eq 1 ]
then
  echo "notification  = Error" >> $CMDFILE
else
  echo "notification  = Always" >> $CMDFILE
fi

# grid
if [ "$GRID" -eq 1 ]
then
  echo "x509userproxy = "$X509USERPROXY >> $CMDFILE
  echo "+RunOnGrid              = True" >> $CMDFILE
  echo "when_to_transfer_output = ON_EXIT" >> $CMDFILE
  echo "transfer_output         = True" >> $CMDFILE
  echo "transfer_error          = True" >> $CMDFILE
  echo "transfer_executable     = False" >> $CMDFILE
  REQUIREMENTS=${REQUIREMENTS}" && (GLIDEIN_Site=!=UNDEFINED)"
  if [ "$NEEDAFS" -eq 1 ]
  then
  echo "+Require_MINOSAFS       = True" >> $CMDFILE
    REQUIREMENTS=${REQUIREMENTS}" && ((Require_MINOSAFS=?=False)||(GLIDEIN_Has_MINOSAFS=?=True))"
  fi
fi

# groups
if [ "$ISTESTJOB" -eq 1 ]
then
  echo '+AccountingGroup = "group_testjobs"' >> $CMDFILE
elif [ -n "$GROUP" ]
then
  echo '+AccountingGroup = "group_'$GROUP'"' >> $CMDFILE
fi

# finish up
echo "requirements  = "$REQUIREMENTS >> $CMDFILE
echo -e ${LINES} >> $CMDFILE
echo "queue "${QUEUECOUNT} >> $CMDFILE


##########################
# now, build the wrapper #
##########################

echo "#!/bin/sh" >> $WRAPFILE
echo "#" >> $WRAPFILE
echo "# "$WRAPFILE >> $WRAPFILE
echo "# Automatically generated by: " >> $WRAPFILE
echo "#      ${thisscript} ${fullargs}" >> $WRAPFILE
echo "" >> $WRAPFILE
echo "# Hold and clear arg list" >> $WRAPFILE
echo "args=\"\$@\"" >> $WRAPFILE
echo "set - \"\"" >> $WRAPFILE
echo "" >> $WRAPFILE

echo "# To prevent output files from being transferred back" >> $WRAPFILE
echo "export _CONDOR_SCRATCH_DIR=\$_CONDOR_SCRATCH_DIR/no_xfer" >> $WRAPFILE
echo "mkdir \$_CONDOR_SCRATCH_DIR" >> $WRAPFILE
echo "" >> $WRAPFILE

if [ -n "$REL" ]
then
  if [ "$FORCEPARROT" -eq 1 ]
  then
    echo "export MINOS_SETUP_DIR=/afs/fnal.gov/files/code/e875/general/minossoft/setup" >> $WRAPFILE
    echo "unset SETUP_UPS SETUPS_DIR" >> $WRAPFILE
    echo ". /afs/fnal.gov/files/code/e875/general/ups/etc/setups.sh" >> $WRAPFILE
  else
    echo "export MINOS_SETUP_DIR=/grid/fermiapp/minos/minossoft/setup" >> $WRAPFILE
  fi
  echo "" >> $WRAPFILE
  echo "setup_minos()" >> $WRAPFILE
  echo "{" >> $WRAPFILE
  echo ". \$MINOS_SETUP_DIR/setup_minossoft_FNALU.sh \$*" >> $WRAPFILE
  echo "}" >> $WRAPFILE
  echo "setup_minos -r "$REL" "$MSOPT >> $WRAPFILE
  echo "# This line is required by some of the CC/nubar analysis code:" >> $WRAPFILE
  echo "export LD_LIBRARY_PATH=\"/grid/fermiapp/minos/lib:\$LD_LIBRARY_PATH\"" >> $WRAPFILE
  if [ -n "$TESTRELDIR" ]
  then
    echo "echo Running \'srt_setup -a\' in "`${RP} $TESTRELDIR` >> $WRAPFILE
    echo "here=\`/bin/pwd\`" >> $WRAPFILE
    echo "cd "`${RP} $TESTRELDIR` >> $WRAPFILE
    echo "srt_setup -a" >> $WRAPFILE
    echo "cd \$here" >> $WRAPFILE
  fi
  echo >> $WRAPFILE
fi

echo "export PATH=\"\${PATH}:.\"" >> $WRAPFILE
echo "" >> $WRAPFILE
echo "# Enstore stuff" >> $WRAPFILE
echo "export MINOS_ENSTORE=$MINOS_ENSTORE" >> $WRAPFILE
echo "source ${MINOS_ENSTORE}/setup_aliases.sh" >> $WRAPFILE
echo "export PATH=\"${MINOS_ENSTORE}:\${PATH}\"" >> $WRAPFILE
echo "" >> $WRAPFILE
echo "# If you use 'enstore_get' or 'enstore_cleanup' in a subscript that" >> $WRAPFILE
echo "# you call, you need to do this in that script:" >> $WRAPFILE
echo "#" >> $WRAPFILE
echo "#    source \$MINOS_ENSTORE/setup_aliases.sh  [OR .csh for csh scripts]" >> $WRAPFILE
echo "#" >> $WRAPFILE
echo "# That's because these two commands are actually aliases and so do not" >> $WRAPFILE
echo "# make it into the daughter script." >> $WRAPFILE
echo "" >> $WRAPFILE
echo "" >> $WRAPFILE

# any directory mapping?  if so, make directories and make them
# group writable for later user cleanup
i=0
while [ $i -lt $TAG_COUNTER ]
do
  echo >> $WRAPFILE
  echo "mkdir -p \$CONDOR_DIR_${TAG_ARRAY[$i]}" >> $WRAPFILE
  echo "chmod g+w \$CONDOR_DIR_${TAG_ARRAY[$i]}" >> $WRAPFILE
  i=$(( i + 1 ))
done

# any Enstore copying?
if [ -n "$ENSTOREFILES" ]
then
  echo >> $WRAPFILE
  echo "enstore_get $ENSTOREFILES" >> $WRAPFILE
fi

echo "# DB stuff -- put after any dCache copying so that the load reporting isn't stale" >> $WRAPFILE
echo "export MINOS_GRIDDB=$MINOS_GRIDDB" >> $WRAPFILE
echo "export PATH=\"${MINOS_GRIDDB}:\${PATH}\"" >> $WRAPFILE
if [ -n "$REL" ]
then
  echo >> $WRAPFILE
  echo "export ENV_TSQL_URL=\`choose_db_server\`" >> $WRAPFILE
  echo "echo Setting database URL to \$ENV_TSQL_URL" >> $WRAPFILE
  echo "" >> $WRAPFILE
fi

echo >> $WRAPFILE
if [ $USEPWD -eq 1 ]
then
  TARGETDIR=`/bin/pwd`
  echo "if [ -d $TARGETDIR ]" >> $WRAPFILE
  echo "then"   >> $WRAPFILE
  echo "  cd $TARGETDIR" >> $WRAPFILE
  echo "else" >> $WRAPFILE
  echo "  echo Cannot change to submission directory $TARGETDIR" >> $WRAPFILE
  echo "  echo ...Working dir is thus \`/bin/pwd\`" >> $WRAPFILE
  echo "fi" >> $WRAPFILE
fi
echo "${USEREXEC} \${args}" >> $WRAPFILE
echo >> $WRAPFILE

# any directory mapping?  if so, make soft links for use by minos_harvestfiles.
# also make group writable any output files made by the minoscvs user
i=0
while [ $i -lt $TAG_COUNTER ]
do
  echo "chmod -R g+w \$CONDOR_DIR_${TAG_ARRAY[$i]}" >> $WRAPFILE
  echo "ln -s "`${RP} ${DIR_ARRAY[$i]}`" \$CONDOR_DIR_${TAG_ARRAY[$i]}/locator" >> $WRAPFILE
  i=$(( i + 1 ))
done

# any Enstore cleanup?
if [ -n "$ENSTOREFILES" ]
then
  echo "enstore_cleanup" >> $WRAPFILE
  echo >> $WRAPFILE
fi

# chmod wrapper
chmod a+x $WRAPFILE


##########
# parrot #
##########

if [ "$USEPARROT" -eq 1 ]
then
  SCRIPT_PATH=`which ${thisscript}`
  SCRIPT_DIR=`dirname ${SCRIPT_PATH}`
  PARROT_TEMPLATE=${SCRIPT_DIR}/parrot_template.sh
  if [ ! -e ${PARROT_TEMPLATE} ]
  then
    echo "minos_jobsub: FATAL!  parrot_template.sh is not where it should"
    echo "be.  Contact an administrator."
    exit 1
  fi
  sed "s@WRAPFILETAG@$WRAPFILE@" ${PARROT_TEMPLATE} > ${PARROTFILE}
  chmod a+x ${PARROTFILE}

  ### who's using parrot
  SPYCMD=/grid/fermiapp/minos/minossoft/setup/datagram/datagram_client.py
  if [ -f $SPYCMD ]; then
    $SPYCMD "minos_jobsub used parrot: ($USER) $USEREXEC $USERARGS"
  fi
fi

##########
# submit #
##########

# are we submitting?
if [ "$SUBMIT" -eq 1 ]
then
  echo "Created $CMDFILE"
  if [ "`hostname`" = "minos25.fnal.gov" ]
  then
    # cd /tmp --> temporary fix to keep shadow exceptions from happening
    curr=`/bin/pwd` ; cd /var/empty
    /opt/condor/bin/condor_submit $CMDFILE
    cd $curr
  else
    ssh -akx minos25.fnal.gov "/bin/bash -c \"cd /var/empty ; \
         export CONDOR_CONFIG=/opt/condor/etc/condor_config ; \
         /opt/condor/bin/condor_submit $CMDFILE\""
    status=$?
    if [ "$status" -ne 0 ]
    then
      echo "Nonzero return status.  Job may not have been submitted."
    fi
  fi
else
  echo $CMDFILE
fi

exit

20140415   kreymer

Changed /tmp to /var/empty working dirctory to evade condor output

