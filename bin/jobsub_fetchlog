#!/usr/bin/python3 -I

#
# jobsub_fetchlog -- tool for downloading job output files from condor
# COPYRIGHT 2022 FERMI NATIONAL ACCELERATOR LABORATORY
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
#
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import sys
import os
import subprocess
import shutil

import htcondor

#
# we are in prefix/bin/jobsub_fetchlog, so find our prefix
#
PREFIX = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

#
# find parts we need in package management
#
sys.path.append(os.path.join(PREFIX, "lib"))

#
# import our local parts
#
import creds
from get_parser import get_jobid_parser
from condor import Job
from utils import cleanup
from tracing import as_span


@as_span("transfer_data")
def traced_transfer_data(j: Job) -> None:
    j.transfer_data()


@as_span("archive")
def traced_wait_archive(p: subprocess.Popen) -> int:
    return p.wait()


@as_span("jobsub_fetchlog", is_main=True)
def main():
    """script mainline:
    - parse args
    - get credentials
    - get job info
    - condor_transfer_data
    - make tarball
    """
    parser = get_jobid_parser()

    parser.add_argument(
        "--destdir",
        "--dest-dir",
        "--unzipdir",
        help="Directory to automatically unarchive logs into",
    )
    parser.add_argument(
        "--archive-format",
        help='format for downloaded archive: "tar" (default, compressed with gzip) or "zip"',
        default="tar",
    )

    args = parser.parse_args()

    if not args.jobid and not args.job_id:
        raise SystemExit("jobid is required.")

    if not args.jobid and args.job_id:
        args.jobid = args.job_id

    if args.verbose:
        htcondor.set_subsystem("TOOL")
        htcondor.param["TOOL_DEBUG"] = "D_FULLDEBUG"
        htcondor.enable_debug()

    if os.environ.get("GROUP", None) is None:
        raise SystemExit(
            "%s needs -G group or $GROUP in the environment." % sys.argv[0]
        )

    proxy, token = creds.get_creds(vars(args))

    if args.verbose:
        print("proxy is : %s" % proxy)
        print("token is : %s" % token)

    # find where the condor_transfer_data will put the output
    j = Job(args.jobid)

    iwd = j.get_attribute("SUBMIT_Iwd")
    if args.verbose:
        print(f"job output to {iwd}")
    # make sure it exists, create if not
    try:
        os.stat(iwd)
    except FileNotFoundError:
        os.makedirs(iwd, mode=0o750)

    # get the output sandbox
    traced_transfer_data(j)
    files = os.listdir(iwd)

    if args.destdir is not None:
        # If the user wants output in a specific directory, copy files there,
        # don't build an archive. Old jobsub would get an archive from the
        # server, upack it into the dest dir, then delete the archive.
        owd = args.destdir
        try:
            os.stat(owd)
        except FileNotFoundError:
            os.makedirs(owd, mode=0o750)
        for f in files:
            shutil.copy2(os.path.join(iwd, f), owd)  # copy2 tries to preserve metadata
    else:
        # build archive
        cmd = []
        if args.archive_format == "tar":
            cmd = ["/usr/bin/tar", "-C", iwd, "-czf", f"{str(j)}.tgz"] + files
            # -C: move into directory so paths are relative
            # -c: create
            # -z: gzip
            # -f: filename
        elif args.archive_format == "zip":
            cmd = ["/usr/bin/zip", "-jq", f"{str(j)}.zip"] + [
                os.path.join(iwd, f) for f in files
            ]
            # -j: junk (don't record) directory names
            # -q: quiet
        else:
            raise Exception(f'unknown archive format "{args.archive_format}"')
        if args.verbose:
            print(f'running "{cmd}"')
        p = subprocess.Popen(cmd)
        if traced_wait(p) != 0:
            raise Exception(f"error creating archive")

    cleanup({"submitdir": iwd})


if __name__ == "__main__":
    main()
