import os
import sys
import time

#
# we assume everwhere our current directory is in the package 
# test area, so go ahead and cd there
#
os.chdir(os.path.dirname(__file__))


#
# import modules we need to test, since we chdir()ed, can use relative path
#
sys.path.append("../lib")
import creds
import condor
import get_parser
import tarfiles
import utils

class TestUnit:
    """
        Use with pytest... unit tests for ../lib/*.py
    """

    #test_group = "fermilab"
    test_group = "dune"
    test_schedd = "jobsubdevgpvm01.fnal.gov"
    test_vargs = { 
            "debug":             False,
            "executable":         "file:///bin/true",
            "exe_arguments":     [],
            "memory":            "64gb",
            "disk":              "100mb",
            "expected_lifetime": "8h",
            "timeout":           "8h",
            "devserver":         True,
            "environment":       ["USER"],
            "group":             test_group,
            "resource_provides": "usage_model=OPPORTUNISTIC,DEDICATED,OFFSITE" 
        }

    def get_submit_file():
        filename="/tmp/tst{0}.sub".format(os.getpid())
        f = open(filename, "w")
        f.write("""
# generated by jobsub_lite 
# 
universe           = vanilla
executable         = /bin/true
arguments          = 

output             = lookaround.xx.$(Cluster).$(Process).out
error              = lookaround.xx.$(Cluster).$(Process).err
log                = lookaround.xx.$(Cluster).$(Process).log
environment        = CLUSTER=$(Cluster);PROCESS=$(Process);CONDOR_TMP=;BEARER_TOKEN_FILE=.condor_creds/{group}.use;CONDOR_EXEC=/tmp;DAGMANJOBID=$(DAGManJobId);GRID_USER={user};JOBSUBJOBID=$(CLUSTER).$(PROCESS)@jobsubdevgpvm01.fnal.gov;EXPERIMENT={group};SAM_EXPERIMENT=samdev
rank               = Mips / 2 + Memory
job_lease_duration = 3600
notification       = Never
transfer_output    = True
transfer_error     = True
transfer_executable= True
when_to_transfer_output = ON_EXIT_OR_EVICT
transfer_output_files = .empty_file
request_memory = 2048.0
request_disk = 102400.0KB
+JobsubClientDN=""
+JobsubClientIpAddress="131.225.67.71"
+Owner="{user}"
+JobsubServerVersion="lite_v1_0"
+JobsubClientVersion="lite_v1_0"
+JobsubClientKerberosPrincipal=""
+JOB_EXPECTED_MAX_LIFETIME = 28800.0
notify_user = {user}@fnal.gov
+AccountingGroup = "group_{group}.{user}"
+Jobsub_Group="{group}"
+JobsubJobId="$(CLUSTER).$(PROCESS)@jobsubdevgpvm01.fnal.gov"
+Drain = False
+GeneratedBy =" jobsubdevgpvm01.fnal.gov"

+DESIRED_usage_model="OPPORTUNISTIC,DEDICATED"

requirements  = target.machine =!= MachineAttrMachine1 && target.machine =!= MachineAttrMachine2  && (isUndefined(DesiredOS) || stringListsIntersect(toUpper(DesiredOS),IFOS_installed)) && (stringListsIntersect(toUpper(target.HAS_usage_model, toUpper(my.DESIRED_usage_model))))

#
# this is supposed to get us output even if jobs are held(?)
#
+SpoolOnEvict = false
#
#
#
use_oauth_services = {group}

queue 1
        """.format( user = os.environ["USER"], group = TestUnit.test_group ))
        f.close()
        return filename

    def get_dag_file():
        filename="/tmp/tst{0}.dag".format(os.getpid())
        f = open(filename, "w")
        f.write("""
        """)
        f.close()
        return filename

    # lib/get_parser.py routines...

    def test_get_parser_1(self):
        parser = get_parser.get_parser()
        line = "jobsub_submit --devserver -e SAM_EXPERIMENT -G {0} --resource-provides=usage_model=OPPORTUNISTIC,DEDICATED,OFFSITE file://`pwd`/lookaround.sh".format(TestUnit.test_group)
        res = parser.parse_args(line.strip().split()[1:])
        assert res.devserver
        assert 'SAM_EXPERIMENT' in res.environment
        assert res.group == TestUnit.test_group

    def test_get_parser_2(self):
        # try to extract all the --foo arguments from the source
        # and track which ones are flags
        f = open("../lib/get_parser.py","r")
        flagargs = set()
        listargs = set()
        allargs = []
        dest = {}
        for line in f.readlines():
            p = line.find('"--')
            if p > 0:
                arg = line[p+3:]
                arg = arg[0:arg.find('"')]
                allargs.append(arg)
                dest[arg] = arg
            if line.find('dest="') > 0:
                dest[arg] = line[line.find('dest="')+6:]
                dest[arg] = dest[arg][0:dest[arg].find('"')]
            if line.find('"-d"') > 0:
                arg = "d"
                allargs.append(arg)
                dest[arg] = arg
            if line.find('"-f"') > 0:
                arg = "f"
                allargs.append(arg)
                dest[arg] = arg
            if line.find('action="store') > 0:
                flagargs.add(arg)
            if line.find('action="append') > 0:
                listargs.add(arg)

        f.close()
        # now make a filled argument list
        filledargs = []
        for arg in allargs:
            if arg in flagargs:
                filledargs.append("--%s" % arg)
            elif arg == "f":
                filledargs.append("-f")
                filledargs.append("xxfxx")
            elif arg == "d":
                filledargs.append("-d")
                filledargs.append("dtag")
                filledargs.append("dpath")
            else:
                filledargs.append("--%s=xx%sxx" % (arg, arg))

        filledargs.append("file://bin/true")

        print("trying command flags: ", filledargs)
        
        parser = get_parser.get_parser()
        res = parser.parse_args(filledargs)
        vres = vars(res)  
        print("vres is ", vres)
        for arg in allargs:
            uarg = dest[arg].replace('-','_')
            if arg in flagargs:
                assert vres[uarg]
            elif arg == "d":
                assert vres['d'] == [['dtag','dpath']]
            elif arg == "f":
                assert vres['input_file'] == ['xxfxx']
            elif arg in listargs:
                assert vres[uarg] == ["xx%sxx" % arg,]
            else:
                assert vres[uarg] == "xx%sxx" % arg

    # lib/creds.py routines...

    def test_get_creds_1(self):
        # to actually submit we do need creds, and our group set...
        os.environ["GROUP"] = TestUnit.test_group
        creds.get_creds()
        assert os.path.exists(os.environ["X509_USER_PROXY"])
        assert os.path.exists(os.environ["BEARER_TOKEN_FILE"])

    # lib/condor.py routines...

    def test_get_schedd_1(self):
        schedd =  condor.get_schedd(TestUnit.test_vargs)
        print("got schedd: {0}".format(schedd))
        print("schedd name: {0}".format(schedd['Name']))
        assert schedd['Name'] == TestUnit.test_schedd

    def test_load_submit_file_1(self):
        res = condor.load_submit_file(TestUnit.get_submit_file())
        assert str(res[0]).find('universe = vanilla') >= 0
        assert str(res[0]).find('executable = /bin/true') >= 0

    def test_submit_1(self):
        # to actually submit we do need creds, and our group set...
        os.environ["GROUP"] = TestUnit.test_group
        creds.get_creds()

        res = condor.submit(TestUnit.get_submit_file(), TestUnit.test_vargs, TestUnit.test_schedd )
        print("got: " , res)
        assert res

    def x_test_submit_dag_1(self):
        # XXX fix me
        res = condor.submit_dag(TestUnit.get_dag_file(), TestUnit.test_vargs, TestUnit.test_schedd, cmd_args=[])

    # lib/tarfiles.py routines...

    def test_tar_up_1(self):
        tarfile = tarfiles.tar_up(os.path.dirname(__file__), None)
        assert os.path.exists(tarfile)
        os.unlink(tarfile)

    def test_slurp_file_1(self):
        digest, tf = tarfiles.slurp_file(__file__)
        assert len(digest) == 64

    def test_dcache_persistent_path_1(self):
        path = tarfiles.dcache_persistent_path(TestUnit.test_group, __file__)
        assert path[:6] == '/pnfs/'

    def test_tarfile_publisher_1(self):
        # need creds..
        os.environ["GROUP"] = TestUnit.test_group
        proxy, token = creds.get_creds()
        # need something to publish...
        tarfile = tarfiles.tar_up(os.path.dirname(__file__), None)
        digest, tf = tarfiles.slurp_file(tarfile)
        cid = f"{TestUnit.test_group}/{digest}"

        publisher = tarfiles.TarfilePublisherHandler(cid, proxy, token)
        location = publisher.cid_exists()

        #
        # code cloned from do_tarballs... this logic should
        # probably be a callable method..
        #
        if location is None:
            publisher.publish(tf)
            for i in range(20):
                 time.sleep(30)
                 location = publisher.cid_exists()
                 if location is not None:
                      break
        else:
            publisher.update_cid()

        assert location is not None

    def test_do_tarballs_1(self):
        # need credentials...
        os.environ["GROUP"] = TestUnit.test_group
        creds.get_creds()

        tdir = os.path.dirname(__file__)
        for dropbox_type in [ "cvmfs", "pnfs" ]:
            argv = [
                "--tar_file_name", "tardir:{0}".format(tdir),
                "--use-{0}-dropbox".format(dropbox_type),
                "--group", TestUnit.test_group,
                "file:///bin/true",
            ]
            parser = get_parser.get_parser()
            args = parser.parse_args(argv)
            tarfiles.do_tarballs(args)
            assert args.tar_file_name[0][:6] == "/{0}/".format(dropbox_type)[:6]

    def x_test_do_tarballs_2(self):
        # should have another one here to test dropbox:xxx 
        pass

    def x_test_do_tarballs_3(self):
        # should have another one here to test existing /cvmfs path
        pass

    #
    # utils.py routines...
    #

    def test_fixquote_1(self):
        assert utils.fixquote('test1') == 'test1'
        assert utils.fixquote('test2=test3') == 'test2="test3"'
        assert utils.fixquote('test2=test3=test4') == 'test2="test3=test4"'

    def test_grep_n_1(self):
        assert utils.grep_n(r"class (\w*):", 1, __file__) == "TestUnit"
        assert utils.grep_n(r"import (\w*)", 1, __file__) == "os"

    def test_fix_unit_1(self):
        args = TestUnit.test_vargs.copy()
        memtable = {"k": 1.0 / 1024, "m": 1, "g": 1024, "t": 1024 * 1024}
        utils.fix_unit(args, "memory", memtable, -1, "b", -2)
        assert args["memory"] == 64 * 1024

    def test_get_principal_1(self):
        # blatantly assumes you have a valid principal...
        res = utils.get_principal()
        assert res.split('@')[0] == os.environ['USER']

    def test_set_extras_1(self):
        os.environ["GROUP"] = TestUnit.test_group
        proxy, token = creds.get_creds()
        args = TestUnit.test_vargs.copy()
        utils.set_extras_n_fix_units(args, TestUnit.test_schedd, proxy, token)
        assert args["user"] == os.environ["USER"]
        assert args["memory"] == 64 * 1024


